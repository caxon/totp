# this file has to be run from the totp root directory. The bash script: $totp_dir/scripts/create-aliases will make sure of that
# and that is the recommend way to run this.
import logging
import os
import re
from pathlib import Path
import sys
import argparse

from .constants import (
    TOTP_BLOCK_END,
    TOTP_BLOCK_START,
    RC_FILE,
    LOGIN_HOST_ALIAS,
    DEFAULT_LOG_FORMAT,
)


# aliases useful for f-strings (left, right brace)
LBRACE = "{"
RBRACE = "}"


def make_totp_block(totp_project_dir):
    return rf"""{TOTP_BLOCK_START}
# auto-generated by totp app: to remove, run "uninstall-totp-app"
alias start-ssh="{totp_project_dir}/scripts/start-ssh"
alias stop-ssh="ssh -O stop {LOGIN_HOST_ALIAS}"
alias uninstall-totp-app="{totp_project_dir}/scripts/uninstall"
{TOTP_BLOCK_END}

"""


def check_for_alias_block(filetext: str, delete_and_return=False):
    """Check if totp aliases chunk is present in filetext
    True if the alias block is defined in the text
    False if the alias block does not exist

    delete (deafult=False): if True, remove everything between the start and end of the alias block, and return the new string
    """

    pattern = rf"^{TOTP_BLOCK_START}\n(.+?\n){LBRACE}0,10{RBRACE}{TOTP_BLOCK_END}$(\n)*"
    m = re.search(pattern, filetext, re.MULTILINE)

    if not m:
        # string not detected in filetext
        return False

    if not delete_and_return:
        # string found, no need to do anything else
        return True

    # return the original filetext without the mached section
    # delete_and_return is True
    subbed_text = re.sub(pattern, "", filetext, flags=re.MULTILINE)
    return subbed_text


def create_aliases(totp_project_dir, rc_file=RC_FILE):
    rc_file_full = Path(rc_file).expanduser()

    if not rc_file_full.exists():
        raise Exception(
            f"RC FILE AT {str(rc_file_full)} does not exist. Exiting script"
        )

    with open(rc_file_full, "rt") as f:
        rc_text = f.read()

        is_alias_there = check_for_alias_block(rc_text)

        if is_alias_there:
            logging.error(f"""TOTP alias likely already in shell config file {str(rc_file)}
If this is an error, remove text from your config file including and between: {TOTP_BLOCK_START} ... {TOTP_BLOCK_END}
Exiting without making changes\n""")
            raise Exception("Aliases already exist")

    totp_block = make_totp_block(totp_project_dir)
    new_rc_text = f"{rc_text}{totp_block}"

    with open(rc_file_full, "wt") as f:
        logging.info(f"Saving file:{str(rc_file)} with TOTP aliases section added")
        f.write(new_rc_text)
        logging.info(f'Restart shell or run: "source {str(rc_file)}" to take effect')


def remove_aliases(rc_file=RC_FILE):
    rc_file_full = Path(rc_file).expanduser()

    with open(rc_file_full, "r") as f:
        rc_text = f.read()
        new_rc_text = check_for_alias_block(rc_text, delete_and_return=True)

    if not new_rc_text:
        logging.warning(
            f"TOTP alias section does not exist in config file {str(rc_file)}\nExiting without making changes\n"
        )
        raise Exception(f"alias text does not exist in shell config file{str(rc_file)}")

    with open(rc_file_full, "wt") as f:
        logging.info(f"Saving file: {str(rc_file)} with TOTP alias section removed")
        f.write(new_rc_text)
        logging.info(
            f'Open new shell or source config to notice changes: "source {str(rc_file)}"'
        )


if __name__ == "__main__":
    logging.basicConfig(format=DEFAULT_LOG_FORMAT, level=logging.INFO)

    parser = argparse.ArgumentParser()
    parser.add_argument(
        "action", help='action involving rc file aliases (e.g "create" or "remove")'
    )
    args = parser.parse_args()
    action = args.action.lower()
    match action:
        case "create":
            try:
                totp_project_dir = os.getcwd()
                create_aliases(totp_project_dir=totp_project_dir)
            except Exception as e:
                sys.exit(1)
        case "remove":
            try:
                remove_aliases()
            except Exception as e:
                sys.exit(1)
        case _:
            raise Exception(f"action arg is not defined: {action}")
